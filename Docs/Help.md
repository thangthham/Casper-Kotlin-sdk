# Kotlin Casper SDK manual on classes and methods

## RPC Calls

The calling the RPC follow this sequence: 

- Create the POST request with corresponding paramters for each methods

- Send the POST request to the Casper server (test net or main net or localhost) 

- Get the Json message back from the server. The message could either be error message or the json string representing the object need to retrieve. If you send wrong parameter,  such as in "chain_get_state_root_hash" RPC call,  if you send BlockIdentifier with too big block height (that does not exist) then you will get error message back from Casper server. If you send correct parameter,  you will get expected json message for the data you need.

- Handle the data sent back from Casper server for the POST request. Depends on the RPC method call,  the corresponding json data is sent back in type of [String: Value] form. The task of the SDK is to parse this json data and put in correct data type built for each RPC method.

## List of RPC methods: 

1) [Get state root hash (chain_get_state_root_hash)](#i-get-state-root-hash)

2) [Get peer list (info_get_peers)](#ii-get-peers-list)

3) [Get Deploy (info_get_deploy)](#iii-get-deploy)

4) [Get Status (info_get_status)](#iv-get-status)

5) [Get Block transfer (chain_get_block_transfers)](#v-get-block-transfers)

6) [Get Block (chain_get_block)](#vi-get-block)

7) [Get Era by switch block (chain_get_era_info_by_switch_block)](#vii-get-era-info-by-switch-block)

8) [Get Item (state_get_item)](#vii-get-item)

9) [Get Dictionary item (state_get_dictionary_item)](#ix-get-dictionaray-item)

10) [Get balance (state_get_balance)](#x-get-balance)

11) [Get Auction info (state_get_auction_info)](#xi-get-auction-info)

12) [Put Deploy (account_put_deploy)](#xii-put-deploy)

### I. Get State Root Hash  

The task is done in file "GetStateRootHashRPC.kotlin" in package "com.casper.sdk.getstateroothash"

#### 1. Method declaration

```Kotlin
@Throws(IllegalArgumentException: :  class)
    fun getStateRootHash(parameterStr:  String):  String
```

#### 2. Input & Output:  

Input:  parameterStr represents the json parameter needed to send along with the POST method to Casper server. This parameter is build based on the BlockIdentifier.

Output:  the string represents the state root hash.

Input generation:  The input for calling chain_get_state_root_hash RPC is generated by the BlockIdentifier class. When call this RPC method to get the state root hash,  you need to declare a BlockIdentifier object and then assign the height or hash or just none to the BlockIdentifier. Then the BlockIdentifier is transfer to the parameterStr parameter. The whole sequence can be seen as the following code: 
1. Declare a BlockIdentifier and assign its value
```Kotlin
    val bi:  BlockIdentifier = BlockIdentifier()
    bi.blockType = BlockIdentifierType.NONE
    
    //or you can set the block attribute like this
    
    bi.blockType = BlockIdentifierType.HASH
    bi.blockHash = "fe35810a3dcfbf853b9d3ac2445fe1fa4aaab047d881d95d9009dc257d396e7e"
   
  // or like this
   
   bi.blockType = BlockIdentifierType.HEIGHT
   bi.blockHeight = 3345u
   
   //then you generate the jsonString to call the getStateRootHashWithJsonParam function
    val parameter: String = bi.toJsonStr(ConstValues.RPC_GET_STATE_ROOT_HASH)
```
2. Use the parameter as input to call the function: 

```Kotlin
try {
   val stateRootHash = getStateRootHash(parameter)
   } catch(e: IllegalArgumentException) {}
```

There can be error if the BlockIdentifier send the too big block Height,  or wrong block Hash. In each case,  the try - catch block is implemented to catch the error and show the result if the request is correct.

#### 3. The Unit test file for GetStateRootHash is in file "GetStateRootHashTest.kotlin". 

Here is the example of getting the state root hash with block identifier set to none (without block hash or block height)

```Kotlin
    var getStateRootHashTest: GetStateRootHashRPC = GetStateRootHashRPC()
        //Call 1:  Get state root hash with non parameter
        val bi:  BlockIdentifier = BlockIdentifier()
        bi.blockType = BlockIdentifierType.NONE
        val str: String = bi.toJsonStr(ConstValues.RPC_GET_STATE_ROOT_HASH)
        try {
           val stateRootHash1 = getStateRootHashTest.getStateRootHash(str)
           assert(stateRootHash1.length>0)
        } catch (e: IllegalArgumentException) {}
```

Here is the example of getting the state root hash with block identifier with correct block hash

```Kotlin
  bi.blockType = BlockIdentifierType.HASH
        bi.blockHash = "fe35810a3dcfbf853b9d3ac2445fe1fa4aaab047d881d95d9009dc257d396e7e"
        val str2: String = bi.toJsonStr(ConstValues.RPC_GET_STATE_ROOT_HASH)
        try {
            var stateRootHash2 = getStateRootHashTest.getStateRootHash(str2)
            assert(stateRootHash2 == "bb3a1f9325c1da6820358f9b4981b84e0c28d924b0ef5776f6bb4cdd1328e261")
        } catch (e: IllegalArgumentException){}
```

### II. Get Peers List  

The task is done in file "GetPeersRPC.kotlin" in package "com.casper.sdk.getpeers"

#### 1. Method declaration

```Kotlin
fun getPeers():  GetPeersResult
```

#### 2. Input & Output:  

Input:  None. When send the POST method to server,  the following fixed string parameter is sent: 

```Kotlin
{"params" :  [], "id" :  1, "method": "info_get_peers", "jsonrpc" :  "2.0"}
```

The result in Json is then parsed back to GetPeersResult class object,  with the following code: 

```Kotlin
 var getPeersResult: GetPeersResult = GetPeersResult()
        getPeersResult.api_version = json.get("result").get("api_version").toString()
        if (peerList is JsonArray) {
            for(peer in peerList) {
                var onePeerEntry: PeerEntry = PeerEntry()
                onePeerEntry.address = peer.get("address").toString()
                onePeerEntry.node_id = peer.get("node_id").toString()
                getPeersResult.peers.add(onePeerEntry)
            }
        }
```

#### 3. The Unit test file for GetPeerResult is in file "GetPeersTest.kotlin"

The function getPeers in this file do just simple work of declare a GetPeerRPC class object and call the getPeers() function from this object,  to get the getPeersResult object.

```Kotlin
val getPeers = GetPeersRPC()
val getPeersResult = getPeers.getPeers()
```

The result is then put into assertion. Since the number of the peer can vary among the call,  then only the assertion of number of peer > 0 is tested and the first peer information is printed out
```Kotlin
assert(getPeersResult.api_version.length>0)
assert(getPeersResult.peers.size>0)
val onePeerEntry: PeerEntry = getPeersResult.peers[0]
println("First peer entry nodeId: ${onePeerEntry.node_id} and address: ${onePeerEntry.address}")
```

### III. Get Deploy 

#### 1. Method declaration

The call for Get Deploy RPC method is done through this function in "GetDeployRPC.kotlin" file in package "com.casper.sdk.getdeploy"

```Kotlin
 @Throws(IllegalArgumentException: : class)
    fun getDeployFromJsonStr(str: String): GetDeployResult
```

#### 2. Input & Output:  

Input:  The input is generated by using file "GetDeployParams.kotlin"

Input is the string of parameter sent to Http Post request to the RPC method,  which in form of

```Kotlin
{"id" :  1, "method" :  "info_get_deploy", "params" :  {"deploy_hash" :  "6e74f836d7b10dd5db7430497e106ddf56e30afee993dd29b85a91c1cd903583"}, "jsonrpc" :  "2.0"}
```

To generate such string,  you need to use GetDeployParams class,  which declared in file "GetDeployParams.kotlin" 

Instantiate the GetDeployParams,  then assign the deploy_hash to the object and use function generatePostParam to generate such parameter string like above.

Sample  code for this process

```Kotlin
val getDeployParams = GetDeployParams()
getDeployRPC.postURL = ConstValues.TESTNET_URL
getDeployParams.deploy_hash = "9ff98d8027795a002e41a709d5b5846e49c2e9f9c8bfbe74e4c857adc26d5571"
val postParameter = getDeployParams.generatePostParameterStr()
```

Then you can call the function of getting the GetDeployResult with the just generated postParameter,  like this call: 

```Kotlin
try {
    val getDeployResult = getDeployRPC.getDeployFromJsonStr(postParameter)
} catch(e: IllegalArgumentException) {}

```

Output:  The ouput is the GetDeployResult class object,  which hold all the information of a deploy such as deploy hash,  deploy header,  deploy session,  deploy payment,  deploy approvals and list of JsonExecutionResult

Exception:  There can be error getting the deploy when the input parameter of the calling function getDeployFromJsonStr is passed with wrong deploy hash. In this case and exception is thrown.

### IV. Get Status

#### 1. Method declaration

The call for Get Status RPC method is done through this function in "GetStatusRPC.kotlin" file

```Kotlin
fun getStatusResult() :  GetStatusResult
```

From this the GetStatusResult is retrieved through this function,  also in "GetStatusResult.m" file

```Kotlin
+(GetStatusResult *) fromJsonDictToGetStatusResult: (NSDictionary*) jsonDict
```

#### 2. Input & Output:  

* For function 

```Kotlin
fun getStatusResult() :  GetStatusResult
```

Input:  there is no input calling this function. In this function,  a parameter with the following content is sent to the HTTP POST method 
```Kotlin
{"params" :  [], "id" :  1, "method": "info_get_status", "jsonrpc" :  "2.0"}
```

Output:  The GetStatusResult which contains all information of the status. From this result you can retrieve information such as:  api_version, chainspec_name, starting_state_root_hash, peers, last_added_block_info...

### V. Get Block Transfers

#### 1. Method declaration

The call for Get Block Transfers RPC method is done through this function in "GetBlockTransferRPC.kotlin" file in package "com.casper.sdk.getblocktransfer"

```Kotlin
 @Throws(IllegalArgumentException: : class)
    fun getBlockTransfer(parameterStr: String): GetBlockTransfersResult 
```

#### 2. Input & Output:  

Input:  parameterStr is a JsonString of such value: 
```Kotlin
{"method" :  "chain_get_block_transfers", "id" :  1, "params" :  {"block_identifier" :  {"Hash" : "d16cb633eea197fec519aee2cfe050fe9a3b7e390642ccae8366455cc91c822e"}}, "jsonrpc" :  "2.0"}
```

Input generation:  The input is generated by the BlockIdentifier class. When call this RPC method to get the state root hash,  you need to declare a BlockIdentifier object and then assign the height or hash or just none to the BlockIdentifier. Then the BlockIdentifier is transfer to the parameterStr parameter. The whole sequence can be seen as the following code: 
1. Declare a BlockIdentifier and assign its value
```Kotlin
    val bi:  BlockIdentifier = BlockIdentifier()
    bi.blockType = BlockIdentifierType.NONE
    
    //or you can set the block attribute like this
    
    bi.blockType = BlockIdentifierType.HASH
    bi.blockHash = "fe35810a3dcfbf853b9d3ac2445fe1fa4aaab047d881d95d9009dc257d396e7e"
   
  // or like this
   
   bi.blockType = BlockIdentifierType.HEIGHT
   bi.blockHeight = 3345u
   
   //then you generate the jsonString to call the getStateRootHashWithJsonParam function
    val parameter: String = bi.toJsonStr(ConstValues.RPC_CHAIN_GET_BLOCK_TRANSFER)
```

Output:  The GetBlockTransfersResult which contains all information of the Block Transfers. From this result you can retrieve information such as:  api_version, block_hash,  list of transfers. (Transfer is wrap in class Transfer.h and all information of Transfer can retrieve from this result).

Exception:  An error is thrown when you send the wrong block height as parameter (for example the height is too big)

### VI. Get Block 

#### 1. Method declaration

The call for Get Block Transfers RPC method is done through this function in "GetBlockRPC.kotlin" file in package "com.casper.sdk.getblock"

```Kotlin
@Throws(IllegalArgumentException: : class)
    fun getBlock(parameterStr: String):  GetBlockResult
```

#### 2. Input & Output:  

Input:  parameterStr is a JsonString of such value: 
```Kotlin
{"method" :  "chain_get_block", "id" :  1, "params" :  {"block_identifier" :  {"Hash" : "d16cb633eea197fec519aee2cfe050fe9a3b7e390642ccae8366455cc91c822e"}}, "jsonrpc" :  "2.0"}
```

To generate such string,  you need to use an object of type BlockIdentifier class,  which declared in file "BlockIdentifier.kotlin" 

Input generation:  The input is generated by the BlockIdentifier class. When call this RPC method to get the state root hash,  you need to declare a BlockIdentifier object and then assign the height or hash or just none to the BlockIdentifier. Then the BlockIdentifier is transfer to the parameterStr parameter. The whole sequence can be seen as the following code: 
1. Declare a BlockIdentifier and assign its value
```Kotlin
    val bi:  BlockIdentifier = BlockIdentifier()
    bi.blockType = BlockIdentifierType.NONE
    
    //or you can set the block attribute like this
    
    bi.blockType = BlockIdentifierType.HASH
    bi.blockHash = "fe35810a3dcfbf853b9d3ac2445fe1fa4aaab047d881d95d9009dc257d396e7e"
   
  // or like this
   
   bi.blockType = BlockIdentifierType.HEIGHT
   bi.blockHeight = 3345u
   
   //then you generate the jsonString to call the getStateRootHashWithJsonParam function
    val parameter: String = bi.toJsonStr(ConstValues.RPC_CHAIN_GET_BLOCK)
```

Output:  The GetBlockResult which contains all information of the block. From this result you can retrieve information such as:  api_version, JsonBlock object(in which you can retrieve information such as:  blockHash,  JsonBlockHeader, JsonBlockBody,  list of proof)

Exception:  An error is thrown when you send the wrong block height as parameter (for example the height is too big)

### VII. Get Era Info By Switch Block

#### 1. Method declaration

The call for Get Era Info RPC method is done through this function in "GetEraBySwitchBlockRPC.kotlin" file in package "com.casper.sdk.era"

```Kotlin
@Throws(IllegalArgumentException: : class)
    fun getEraInfo(parameterStr: String):  GetEraInfoResult
```

#### 2. Input & Output:  

Input:  parameterStr is a JsonString of such value: 
```Kotlin
{"method" :  "chain_get_era_info_by_switch_block", "id" :  1, "params" :  {"block_identifier" :  {"Hash" : "d16cb633eea197fec519aee2cfe050fe9a3b7e390642ccae8366455cc91c822e"}}, "jsonrpc" :  "2.0"}
```

To generate such string,  you need to use an object of type BlockIdentifier class,  which declared in file "BlockIdentifier.kotlin" 

Input generation:  The input is generated by the BlockIdentifier class. When call this RPC method to get the state root hash,  you need to declare a BlockIdentifier object and then assign the height or hash or just none to the BlockIdentifier. Then the BlockIdentifier is transfer to the parameterStr parameter. The whole sequence can be seen as the following code: 
1. Declare a BlockIdentifier and assign its value
```Kotlin
    val bi:  BlockIdentifier = BlockIdentifier()
    bi.blockType = BlockIdentifierType.NONE
    
    //or you can set the block attribute like this
    
    bi.blockType = BlockIdentifierType.HASH
    bi.blockHash = "fe35810a3dcfbf853b9d3ac2445fe1fa4aaab047d881d95d9009dc257d396e7e"
   
  // or like this
   
   bi.blockType = BlockIdentifierType.HEIGHT
   bi.blockHeight = 3345u
   
   //then you generate the jsonString to call the getStateRootHashWithJsonParam function
    val parameter: String = bi.toJsonStr(ConstValues.RPC_CHAIN_GET_BLOCK)
```

Output:  The GetEraInfoResult which contains all information of the era info. From this result you can retrieve information such as:  api_version,  era_summary (in which you can retrieve information such as:  block_hash,  era_id,  state_root_hash,  merkle_proof,  stored_value).

Exception:  An error is thrown when you send the wrong block height as parameter (for example the height is too big)

### VII. Get Item

#### 1. Method declaration

The call for Get Item RPC method is done through this function in "GetItemRPC.kotlin" file in package "com.casper.sdk.getitem"

```Kotlin
 @Throws(IllegalArgumentException: : class)
    fun getItem(parameterStr: String):  GetItemResult {
```

#### 2. Input & Output:  

Input: parameterStr is a JsonString of such value: 
```Kotlin
{"method" :  "state_get_item", "id" :  1, "params" : {"state_root_hash" :  "d360e2755f7cee816cce3f0eeb2000dfa03113769743ae5481816f3983d5f228", "key": "withdraw-df067278a61946b1b1f784d16e28336ae79f48cf692b13f6e40af9c7eadb2fb1", "path": []}, "jsonrpc" :  "2.0"}
```

To generate such string,  you need to use an object of type GetItemParams class,  which declared in file "GetItemParams.kotlin" in package "com.casper.sdk.getitem"

Instantiate the GetItemParams,  then assign the GetItemParams object with state_root_hash,  key,  and path,  then use function "generateParameterStr" of the "GetItemParams" class to generate such parameter string like above.

Sample  code for this process: 

```Kotlin
var getItemRPC :  GetItemRPC = GetItemRPC()
var getItemParameter: GetItemParams = GetItemParams()
 try {
    getItemParameter.stateRootHash = "340a09b06bae99d868c68111b691c70d9d5a253c0f2fd7ee257a04a198d3818e"
    getItemParameter.key = "uref-ba620eee2b06c6df4cd8da58dd5c5aa6d42f3a502de61bb06dc70b164eee4119-007"
    val params:  String = getItemParameter.generateParameterStr()
    val getItemResult = getItemRPC.getItem(params)
}  catch (e: IllegalArgumentException) {}
```

Output:  The GetItemResult which contains all information of the item. From this result you can retrieve information such as:  api_version, merkle_proof,  stored_value.

Exception:  An error is thrown when you send the wrong parameter,  for example when you pass the wrong state root hash or wrong key,  wrong path


### IX. Get Dictionaray Item

#### 1. Method declaration

The call for Get Dictionary Item RPC method is done through this function in "GetDictionaryItemRPC.kotlin" file in package "com.casper.sdk.getdictionary"

```Kotlin
@Throws(IllegalArgumentException: : class)
    fun getDictionaryItem(parameterStr: String):  GetDictionaryItemResult 
```

#### 2. Input & Output:  

Input:  a JsonString of such value: 
```Kotlin
{"method" :  "state_get_dictionary_item", "id" :  1, "params" : {"state_root_hash" :  "146b860f82359ced6e801cbad31015b5a9f9eb147ab2a449fd5cdb950e961ca8", "dictionary_identifier": {"AccountNamedKey": {"dictionary_name": "dict_name", "key": "account-hash-ad7e091267d82c3b9ed1987cb780a005a550e6b3d1ca333b743e2dba70680877", "dictionary_item_key": "abc_name"}}}, "jsonrpc" :  "2.0"}
```

To generate such string,  you need to use an object of type GetDictionaryItemParams class,  which declared in file "GetDictionaryItemParams.kotlin" in package "com.casper.sdk.getdictionary"

Instantiate the GetDictionaryItemParams,  then assign the GetDictionaryItemParams object with state_root_hash and an DictionaryIdentifier value.
The DictionaryIdentifier can be 1 among 4 possible values,  defined in 4 classes which are:  "DIAccountNamedKey",  "DIContractNamedKey",  "DIDictionary",  "DIURef"
When the state_root_hash and DictionaryIdentifier value are sets,  use function "toJsonString" of the "GetDictionaryItemParams" class to generate such parameter string like above.

Sample  code for this process,  with DictionaryIdentifier of type AccountNamedKey

```Kotlin
val getDictionaryItemRPC: GetDictionaryItemRPC = GetDictionaryItemRPC()
val getDictionaryItemParams :  GetDictionaryItemParams = GetDictionaryItemParams()
val diAccountNamedKey: DIAccountNamedKey = DIAccountNamedKey()
diAccountNamedKey.key = "account-hash-ad7e091267d82c3b9ed1987cb780a005a550e6b3d1ca333b743e2dba70680877"
diAccountNamedKey.dictionaryName = "dict_name"
diAccountNamedKey.dictionaryItemKey = "abc_name"
val di: DictionaryIdentifier = DictionaryIdentifier()
di.itsType = ConstValues.DI_ACCOUNT_NAMED_KEY
di.itsValue.add(diAccountNamedKey)
getDictionaryItemParams.dictionaryIdentifier = di
getDictionaryItemParams.stateRootHash = "146b860f82359ced6e801cbad31015b5a9f9eb147ab2a449fd5cdb950e961ca8"
val parameterStr: String = getDictionaryItemParams.generateParameterStr()
val getDictionaryItemResult: GetDictionaryItemResult = getDictionaryItemRPC.getDictionaryItem(parameterStr)
```

Output:  The GetDictionaryItemResult which contains all information of the dictionary item. From this result you can retrieve information such as:  api_version, dictionary_key,  merkle_proof, stored_value.

Exception:  An error is thrown when you send the wrong parameter,  for example when you pass the wrong state root hash or wrong AccountNamedKey,  ContractNamedKey,  URef or Dictionary inner values of DictionaryIdentifier type.
The test unit provides 2 negative test case with 1 test case sending with wrong state root hash and 1 test case with sending wrong AccountNamedKey inner values.


### X. Get Balance

#### 1. Method declaration

The call for Get Balance RPC method is done through this function in "GetBalanceRPC.kotlin" file in package com.casper.sdk.getbalance

```Kotlin
@Throws(IllegalArgumentException: : class)
    fun getBalance(parameterStr: String):  GetBalanceResult
```

#### 2. Input & Output:  

Input:  parameterStr is a JsonString of such value: 
```Kotlin
{"method" :  "state_get_balance", "id" :  1, "params" : {"state_root_hash" :  "8b463b56f2d124f43e7c157e602e31d5d2d5009659de7f1e79afbd238cbaa189", "purse_uref": "uref-be1dc0fd639a3255c1e3e5e2aa699df66171e40fa9450688c5d718b470e057c6-007"}, "jsonrpc" :  "2.0"}
```

To generate such string,  you need to use an object of type GetBalanceParams class,  which declared in file "GetBalanceParams.kotlin" in package "com.casper.sdk.getbalance"

Instantiate the GetBalanceParams,  then assign the GetBalanceParams with state_root_hash and purse_uref then use function "toJsonString" of the "GetBalanceParams" class to generate such parameter string like above.

Sample  code for this process

```Kotlin
val getBalanceRPC: GetBalanceRPC = GetBalanceRPC()
val getBalanceParams: GetBalanceParams = GetBalanceParams()
getBalanceParams.purseUref = "uref-be1dc0fd639a3255c1e3e5e2aa699df66171e40fa9450688c5d718b470e057c6-007"
getBalanceParams.stateRootHash = "8b463b56f2d124f43e7c157e602e31d5d2d5009659de7f1e79afbd238cbaa189"
val parameterStr: String = getBalanceParams.generateParameter()
val getBalanceResult: GetBalanceResult = getBalanceRPC.getBalance(parameterStr)
```

Output:  The GetBalanceResult which contains all information of the balance. From this result you can retrieve information such as:  api_version, balance_value,  merkle_proof.

Exception:  An error is thrown when you send the wrong parameter,  for example when you pass the wrong state root hash or wrong purse uref parameter.
In the unit test,  2 example of the negative tests are given,  1 for sending with wrong state root hash,  1 for sending with wrong purse uref.

### XI. Get Auction Info

#### 1. Method declaration

The call for Get Auction RPC method is done through this function in "GetAuctionInfoRPC.kotlin" file in package "com.casper.sdk.getauction"

```Kotlin
@Throws(IllegalArgumentException: : class)
    fun getAuctionInfo(parameterStr: String):  GetAuctionInfoResult
```

#### 2. Input & Output:  

Input:  parameterStr is a JsonString of such value: 
```Kotlin
{"method" :  "state_get_auction_info", "id" :  1, "params" :  {"block_identifier" :  {"Hash" : "d16cb633eea197fec519aee2cfe050fe9a3b7e390642ccae8366455cc91c822e"}}, "jsonrpc" :  "2.0"}
```

To generate such string,  you need to use an object of type BlockIdentifier class,  which declared in file "BlockIdentifier.kotlin" 

Input generation:  The input is generated by the BlockIdentifier class. When call this RPC method to get the state root hash,  you need to declare a BlockIdentifier object and then assign the height or hash or just none to the BlockIdentifier. Then the BlockIdentifier is transfer to the parameterStr parameter. The whole sequence can be seen as the following code: 
1. Declare a BlockIdentifier and assign its value
```Kotlin
    val bi:  BlockIdentifier = BlockIdentifier()
    bi.blockType = BlockIdentifierType.NONE
    
    //or you can set the block attribute like this
    
    bi.blockType = BlockIdentifierType.HASH
    bi.blockHash = "fe35810a3dcfbf853b9d3ac2445fe1fa4aaab047d881d95d9009dc257d396e7e"
   
  // or like this
   
   bi.blockType = BlockIdentifierType.HEIGHT
   bi.blockHeight = 3345u
   
   //then you generate the jsonString to call the getStateRootHashWithJsonParam function
    val parameter: String = bi.toJsonStr(ConstValues.RPC_STATE_GET_AUTION_INFO)
```

Output:  The GetAuctionInfoResult which contains all information of the aunction. From this result you can retrieve information such as:  api_version, auction_state (in which you can retrieve information such as state_root_hash,  block_height,  list of JsonEraValidators).

Exception:  An error is thrown when you send the wrong parameter,  for example when you pass the wrong block height (too big block height) in BlockIdentifier. If you pass a BlockIdentifier without block hash or height,  or pass the wrong block hash,  the latest auction info is retrieved.

### XII. Put deploy 

#### 1. Method declaration

The call for Put Deploy RPC method is done through this function in "PutDeployRPC.kotlin" file in package "com.casper.sdk.putdeploy"

```Kotlin
fun putDeploy(deploy: Deploy) :String 
```

#### 2. Input & Output:  

Input: One deploy object that will be posted to the system.

From this deploy, a string for posting that deploy is generated using this function, aslo in file "PutDeployRPC.kotlin"
```Kotlin
fun fromDeployToJsonString(deploy: Deploy):String 
```

The result of this function is a Json string represent the deploy, that can later use as parameter for the POST request.
```Kotlin
{"id": 1,"method": "account_put_deploy","jsonrpc": "2.0","params": [{"header": {"account": "0152a685e0edd9060da4a0d52e500d65e21789df3cbfcb878c91ffeaea756d1c53","timestamp": "2022-06-28T11:35:19.349Z","ttl":"1h 30m","gas_price":1,"body_hash":"798a65dae48dbefb398ba2f0916fa5591950768b7a467ca609a9a631caf13001","dependencies": [],"chain_name": "casper-test"},"payment": {"ModuleBytes": {"module_bytes": "","args": [["amount",{"bytes": "0400ca9a3b","cl_type":"U512","parsed":"1000000000"}]]}},"session": {"Transfer": {"args": [["amount",{"bytes": "04005ed0b2","cl_type":"U512","parsed":"3000000000"}],["target",{"bytes": "015f12b5776c66d2782a4408d3910f64485dd4047448040955573aa026256cfa0a","cl_type":"PublicKey","parsed":"015f12b5776c66d2782a4408d3910f64485dd4047448040955573aa026256cfa0a"}],["id",{"bytes": "010000000000000000","cl_type":{"Option": "U64"},"parsed":0}],["spender",{"bytes": "01dde7472639058717a42e22d297d6cf3e07906bb57bc28efceac3677f8a3dc83b","cl_type":"Key","parsed":{"Hash":"hash-dde7472639058717a42e22d297d6cf3e07906bb57bc28efceac3677f8a3dc83b"}}]]}},"approvals": [{"signer": "0152a685e0edd9060da4a0d52e500d65e21789df3cbfcb878c91ffeaea756d1c53","signature": "016596f09083d32eaffc50556f1a5d22202e8927d5aa3267639aff4b9d3412b5ae4a3475a5da6c1c1086a9a090b0e1090db5d7e1b7084bb60b2fee3ce9447a2a04"}],"hash": "65c6ccdc5aacc9dcd073ca79358bf0b5115061e8d561b3e6f461a34a6c5858f0"}]}
```
The rule for generating the Json string from the deploy is:

First get the deploy header - make it to part of the Json string

Then get the deploy payment - make it to part of the Json string

Get the deploy session - make it to part of the Json string

Get the approval - make it to part of the Json string

Get the deploy - hash - make it to part of the Json string

Build the full Json string for the deploy.

The code for the whole process is done in this code 

```Kotlin
fun fromDeployToJsonString(deploy: Deploy):String {
    val headerString:String = "\"header\": {\"account\": \"" + deploy.header.account + "\",\"timestamp\": \"" + deploy.header.timeStamp + "\",\"ttl\":\""+deploy.header.ttl+"\",\"gas_price\":"+deploy.header.gasPrice+",\"body_hash\":\"" + deploy.header.bodyHash + "\",\"dependencies\": [],\"chain_name\": \"" + deploy.header.chainName + "\"}"
    val paymentJsonStr:String = "\"payment\": " + ExecutableDeployItemHelper.toJsonString(deploy.payment)
    val sessionJsonStr:String = "\"session\": " + ExecutableDeployItemHelper.toJsonString(deploy.session)
    val approvalJsonStr: String = "\"approvals\": [{\"signer\": \"" + deploy.approvals.get(0).signer + "\",\"signature\": \"" + deploy.approvals.get(0).signature + "\"}]"
    val hashStr = "\"hash\": \"" + deploy.hash + "\""
    val deployJsonStr: String = "{\"id\": 1,\"method\": \"account_put_deploy\",\"jsonrpc\": \"2.0\",\"params\": [{" + headerString + ","+paymentJsonStr + "," + sessionJsonStr + "," + approvalJsonStr + "," + hashStr + "}]}"
    println(deployJsonStr)
    return deployJsonStr
}
```

Output:
If the deploy is sent successfully to the system, then the result will be a Json string back like this
```Kotlin
{
    "jsonrpc": "2.0",
    "id": 1,
    "result": {
        "api_version": "1.4.6",
        "deploy_hash": "65c6ccdc5aacc9dcd073ca79358bf0b5115061e8d561b3e6f461a34a6c5858f0"
    }
}
```

Then this function 

```Kotlin
fun putDeploy(deploy: Deploy) :String 
```

will parse the Json string and take the "deploy_hash" value and return it back as output.

If the deploy fails to send to the system, then the result will be a Json string back like this:
```Kotlin
{
    "jsonrpc": "2.0",
    "id": 1,
    "error": {
        "code": -32602,
        "message": "Invalid params",
        "data": null
    }
}
```

Then this function 

```Kotlin
fun putDeploy(deploy: Deploy) :String 
```

will parse the error message string return it back as output.

#### Put deploy test 

There are positive and negative test cases for putting deploy of Ed25519 account and Secp256k1 account.

The Ed25519 account is using this account "0152a685e0edd9060da4a0d52e500d65e21789df3cbfcb878c91ffeaea756d1c53" which you can see the account detail at this address https://testnet.cspr.live/account/0152a685e0edd9060da4a0d52e500d65e21789df3cbfcb878c91ffeaea756d1c53

The Secp256k1 account is using this account "0202d3de886567b1281eaa5687a85e14b4f2922e19b89a3f1014c7932f442c9d9635" which you can see the account detail at this address https://testnet.cspr.live/account/0202d3de886567b1281eaa5687a85e14b4f2922e19b89a3f1014c7932f442c9d9635

The test is done in file "PutDeployRPCTest" under package "com.casper.sdk.putdeploy" of the "test" folder.

The function for doing the positive test for both Ed25519 and Secp256k1 is 

```Kotlin
private fun testPutDeploy(isEd25519:Boolean) : String
```

This function takes parameter of isEd25519 with value true or false. If the value of the input is true, then the account of type Ed25519 is used, otherwise the account of type Secp256k1 is used.

The procedure for making a positive test is to create a deploy by assigning its header value. All the value for deploy header except for the body hash can be assigned by putting sample value.
Then the payment and session of the deploy is assign by putting sample value for a transfer deploy.
The deploy body hash is then calculated based on the payment and session of the deploy by calling this code line: 

```Kotlin
val deployBodyHash:String = Deploy.getBodyHash(deploy)
```
The body hash is generated by using blake2b256 over the (paymentSerialization + sessionSerialization)

Then the header.body_hash is assigned by that body hash value.

The deploy hash is generated based on the deploy header, by getting the blake2b256 value over the deployHeaderSerialization.

You also need to generate the signature for the account by using the Ed25519 or Secp256k1 Crypto function, based on the account you are using to put the deploy. The signature is generated by siging the account with the Ed25519 or Secp256k1 private key.

For Ed25519 account, the private key for signing the account is loaded from the file "KotlinEd25519PrivateKey.pem" under folder "Ed25519" of the SDK. The private key is read from the Pem file, then a signature with length of 128 will be generated, and a prefix of "01" will be added to the signature to make the real signature to use for putting the deploy. The pem file "KotlinEd25519PrivateKey.pem" is generated from Casper Signer from the account of the Ed25519 account.

For Secp256k1 account, the private key for signing the account is loaded from the file "KotlinSecp256k1PrivateKey.pem" under folder "Secp256k1" of the SDK. The private key is read from the Pem file, then a signature with length of 128 will be generated, and a prefix of "02" will be added to the signature to make the real signature to use for putting the deploy. The pem file "KotlinSecp256k1PrivateKey.pem" is generated from Casper Signer from the account of the Secp256k1 account.

After each time the "PutDeployRPCTest" is called, there will be transfer deploy listed in the account. Scroll down the page for Ed25519 or Secp256k1 account to see the list of deploy being created.

For example this is the list of deploys being created for account "0152a685e0edd9060da4a0d52e500d65e21789df3cbfcb878c91ffeaea756d1c53" by going to this address https://testnet.cspr.live/account/0152a685e0edd9060da4a0d52e500d65e21789df3cbfcb878c91ffeaea756d1c53 and scroll down.

<img width="1440" alt="Screen Shot 2022-06-28 at 14 25 55" src="https://user-images.githubusercontent.com/94465107/176119681-b338c053-1a99-4270-8c91-cef4b3d24798.png">

This is the list of the deploys being created for account "0202d3de886567b1281eaa5687a85e14b4f2922e19b89a3f1014c7932f442c9d9635" by going to this address 
 https://testnet.cspr.live/account/0202d3de886567b1281eaa5687a85e14b4f2922e19b89a3f1014c7932f442c9d9635 and scroll down.
 
 <img width="1440" alt="Screen Shot 2022-06-28 at 14 26 30" src="https://user-images.githubusercontent.com/94465107/176119896-42a6b2b9-4c11-4f9c-aa2c-1aff00480ee7.png">
 
The above manual is for exising account in the test net. If you are familiar with the Casper system and Casper Signer, you can create your own Ed25519 or Secp256k1 account and do the test with your account.
 
Here is a brief description of the steps to do:

Install Casper Signer. Create 1 account of type Ed25519 (for example, Secp256k1 is quite the same). Download the private key for the newly created account. Give it a name, for example "Ed25519PrivateKeyKotlin01.pem". Copy the key to the folder "Ed25519" of the SDK.

In file "ConstValues" under package "com.casper.sdk" of the Casper Kotlin SDK find for the variable "PEM_READ_PRIVATE_ED25519", change its value to your pem name "Ed25519PrivateKeyKotlin01.pem".


From Casper test net choose Tool->Faucet and request for a 1000 CSPR token for the newly created account.
