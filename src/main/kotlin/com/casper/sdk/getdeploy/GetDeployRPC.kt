package com.casper.sdk.getdeploy

import com.casper.sdk.ConstValues
import com.casper.sdk.getdeploy.ExecutableDeployItem.ExecutableDeployItem
import com.casper.sdk.getdeploy.ExecutionResult.ExecutionResult
import com.casper.sdk.getdeploy.ExecutionResult.JsonExecutionResult
import net.jemzart.jsonkraken.get
import net.jemzart.jsonkraken.toJson
import net.jemzart.jsonkraken.toJsonString
import net.jemzart.jsonkraken.values.JsonArray
import net.jemzart.jsonkraken.values.JsonObject
import java.net.URI
import java.net.URLEncoder
import java.net.http.HttpClient
import java.net.http.HttpRequest
import java.net.http.HttpResponse
/**Class built for info_get_deploy RPC call */
class GetDeployRPC {
    var methodURL: String = ConstValues.TESTNET_URL
    /**
     * This function initiate the process of sending POST request with given parameter in JSON string format
     * The input parameterStr is used to send to server as parameter of the POST request to get the result back.
     * The input parameterStr is somehow like this:
     * {"id" :  1, "method" :  "info_get_deploy", "params" :  {"deploy_hash" :  "6e74f836d7b10dd5db7430497e106ddf56e30afee993dd29b85a91c1cd903583"}, "jsonrpc" :  "2.0"}
     * The parameterStr is generated by the GetDeployParams class, declared in file GetDeployParams.kotlin
     * Then the GetDeployResult is retrieved by parsing JsonObject result
     * If the result is error,  then an exception is thrown
     * Else the GetDeployResult is taken by parsing the  retrieving JsonObject
     */
    @Throws(IllegalArgumentException:: class)
    fun getDeployFromJsonStr(str: String): GetDeployResult {
        val getDeployResult: GetDeployResult = GetDeployResult()
        val client = HttpClient.newBuilder().build()
        val request = HttpRequest.newBuilder()
            .uri(URI.create(methodURL))
            .POST((HttpRequest.BodyPublishers.ofString(str)))
            .header("Content-Type",  "application/json")
            .build()
        val response = client.send(request,  HttpResponse.BodyHandlers.ofString())
        val json =response.body().toJson()
        //check for error getting deploy
        //error can happen if send the wrong deploy hash
        val jsonError = json.get("error").toJsonString()
        if (jsonError != "null") {
            throw IllegalArgumentException("Deploy hash is not valid")
        }
        val jsonResult: JsonObject = json.get("result") as JsonObject
        getDeployResult.api_version = jsonResult.get("api_version").toString()
        getDeployResult.deploy.header = DeployHeader.fromJsonToDeployHeader(jsonResult.get("deploy").get("header") as JsonObject)
        getDeployResult.deploy.hash = jsonResult.get("deploy").get("hash").toString()
        val deployPayment = jsonResult.get("deploy").get("payment") as JsonObject
        getDeployResult.deploy.payment = ExecutableDeployItem.fromJsonToExecutableDeployItem(deployPayment)
        val deploySession : JsonObject = jsonResult.get("deploy").get("session") as JsonObject
        getDeployResult.deploy.session = ExecutableDeployItem.fromJsonToExecutableDeployItem(deploySession)
        //get approvals
        getDeployResult.deploy.approvals = Deploy.fromJsonToListApprovals(jsonResult.get("deploy").get("approvals") as JsonArray)
        //get execution result
        val listER: JsonArray = jsonResult.get("execution_results") as JsonArray
        val totalER: Int = listER.count()
        for(i in 0.. totalER-1) {
            val jer:  JsonExecutionResult = JsonExecutionResult()
            val oneItem = listER[i]
            jer.blockHash = oneItem.get("block_hash").toString()
            jer.result = ExecutionResult.fromJsonToExecutionResult(oneItem.get("result") as JsonObject)
            getDeployResult.executionResults.add(jer)
        }
        return getDeployResult
    }
}